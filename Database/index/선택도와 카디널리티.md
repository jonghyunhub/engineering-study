최적의 인덱스를 선택하기 위해 고려해야할 것들 중 하나가 카디널리티와 선택도이다.

# 카디널리티 (Cardinality)와 선택도 (Selectivity)

* **카디널리티**: 특정 칼럼의 고유한 값의 개수
* **선택도**: 전체 레코드 중 고유한 값의 비율 (카디널리티 / 전체 레코드 수)
* 카디널리티가 높을수록(고유값이 많을수록) 인덱스를 이용한 조회 효율이 높아진다.

무슨말인지 예시를 통해 알아보자.
```ddl
create table payment(
    orderId int not null primary key,
    userId int not null,
    createdDate Date not null
)
```

가령 다음과 같은 테이블에서 특정 유저가 구입한 주문을 조회한다고 해보자.

총 payment 레코드가 100만 건이고, userId로 인덱스를 추가한다고 해보자.

## 경우 1: userId 인덱스 (카디널리티 높음)

### 데이터 예시

유저가 10만 명이고 유저당 평균 10건의 구매를 했다고 가정하면 데이터는
```
payment 테이블 (총 100만 건)
┌─────────┬────────┬──────────────┐
│ orderId │ userId │ createdDate  │
├─────────┼────────┼──────────────┤
│ 1       │ 100    │ 2025-11-01   │
│ 2       │ 100    │ 2025-11-02   │
│ 3       │ 101    │ 2025-11-01   │
│ 4       │ 102    │ 2025-11-01   │
│ 5       │ 100    │ 2025-11-03   │
│ ...     │ ...    │ ...          │
│ 999998  │ 99999  │ 2025-11-10   │
│ 999999  │ 99999  │ 2025-11-10   │
│ 1000000 │ 100000 │ 2025-11-10   │
└─────────┴────────┴──────────────┘

userId 분포:
┌────────┬────────┐
│ userId │ 건수   │
├────────┼────────┤
│ 100    │ 10건   │
│ 101    │ 10건   │
│ 102    │ 10건   │
│ ...    │ ...    │
│ 100000 │ 10건   │
└────────┴────────┘
총 10만 명 (각 10건씩)
```

이때 다음과 같은 쿼리를 사용하고 유저 아이디에 인덱스가 걸려있다고 가정하자.

```sql
select * 
from payment
where userId = 123
```

### 인덱스 효율성

유저가 10만 명이고 유저당 평균 10건의 구매를 했다고 하면:
- **카디널리티**: 10만 (고유 userId 개수)
- **선택도**: 10만 / 100만 = 0.1 (10%)
- **각 userId당 평균**: 100만 / 10만 = 10건

특정 userId로 조회 시:
```
100만 건 → 인덱스로 10건만 찾음 (매우 효율적)
```

```
인덱스 구조 (userId 기준 정렬):
┌────────┬──────────────┐
│ userId │ Row Pointer  │
├────────┼──────────────┤
│ 100    │ → orderId 1  │
│ 100    │ → orderId 2  │
│ 100    │ → orderId 5  │
│ ...    │ ...          │  (10건)
│ 101    │ → orderId 3  │
│ ...    │ ...          │
│ 123    │ → orderId X  │  ← 여기만 스캔 (10건)
│ ...    │ ...          │
└────────┴──────────────┘

결과: 매우 효율적!
```

## 경우 2: createdDate 인덱스 (카디널리티 낮음)

### 데이터 예시

10일간의 데이터가 100만 건이라고 가정:
```
createdDate 분포:
┌──────────────┬─────────┐
│ createdDate  │ 건수    │
├──────────────┼─────────┤
│ 2025-11-01   │ 10만 건 │
│ 2025-11-02   │ 10만 건 │
│ 2025-11-03   │ 10만 건 │
│ 2025-11-04   │ 10만 건 │
│ 2025-11-05   │ 10만 건 │
│ 2025-11-06   │ 10만 건 │
│ 2025-11-07   │ 10만 건 │
│ 2025-11-08   │ 10만 건 │
│ 2025-11-09   │ 10만 건 │
│ 2025-11-10   │ 10만 건 │
└──────────────┴─────────┘
총 10일 (각 10만 건씩)
```

10일간의 데이터가 100만 건이라고 해보자:
- **카디널리티**: 10 (고유 날짜 개수)
- **선택도**: 10 / 100만 = 0.00001 (0.001%)
- **각 날짜당 평균**: 100만 / 10 = 10만 건
```sql
select * 
from payment
where createdDate = '2025-11-03'
```

특정 날짜로 조회 시:
```
100만 건 → 인덱스로 10만 건 찾음 (비효율적)
```

```
인덱스 구조 (createdDate 기준 정렬):
┌──────────────┬──────────────┐
│ createdDate  │ Row Pointer  │
├──────────────┼──────────────┤
│ 2025-11-01   │ → orderId 1  │
│ 2025-11-01   │ → orderId 4  │
│ ...          │ ...          │  (10만 건)
│ 2025-11-02   │ → orderId 2  │
│ ...          │ ...          │  (10만 건)
│ 2025-11-03   │ → orderId 5  │
│ ...          │ ...          │  ← 여기 전체 스캔 (10만 건!)
└──────────────┴──────────────┘

결과: 비효율적! 여전히 10만 건을 처리해야 함
```

이처럼 **카디널리티(고유값의 개수)** 는 효율적인 인덱스 탐색을 위한 중요한 척도가 된다.

## 주의: 카디널리티가 높아도 비효율적일 수 있음

하지만, 무조건 카디널리티가 높다고 해서 효율적인 탐색을 보장하는 것은 아니다.

### 데이터 분포가 불균등한 경우

처음의 userId 예시에서 일반 유저는 10건 미만이지만, 특정 VIP 유저는 1만 건 이상의 구매를 했다고 가정해보자.
```
userId 분포 (불균등):
┌────────┬────────────┬─────────┐
│ userId │ 유저 타입    │ 건수     │
├────────┼────────────┼─────────┤
│ 1      │ VIP        │ 10,000건│ Bad️
│ 2      │ VIP        │ 10,000건│ Bad️
│ 3      │ VIP        │ 10,000건 │ Bad️
│ ...    │ ...        │ ...     │
│ 100    │ 일반        │ 10건     │ Good
│ 101    │ 일반        │ 8건      │ Good
│ 102    │ 일반        │ 12건     │ Good
│ ...    │ ...        │ ...     │
│ 100000 │ 일반        │ 9건      │ Good
└────────┴────────────┴─────────┘

- VIP 100명: 각 10,000건 = 총 100만 건
- 일반 유저 99,900명: 각 평균 0.1건
```

처음의 userId 예시에서 일반 유저는 10건 미만이지만, 특정 VIP 유저는 1만 건 이상의 구매를 했다고 가정해보자.
```sql
select * 
from payment
where userId = 100  -- VIP 유저 아이디
```

이 경우:
```
100만 건 → 인덱스로 1만 건 찾음
→ 여전히 1만 건을 처리해야 하므로 성능이 느릴 수 있음
```

```
인덱스 구조:
┌────────┬──────────────┐
│ userId │ Row Pointer  │
├────────┼──────────────┤
│ 1      │ → orderId 1  │
│ 1      │ → orderId 15 │
│ 1      │ → orderId 28 │
│ ...    │ ...          │
│ 1      │ → orderId X  │  ← 1만 건이나 스캔해야 함!
│ 2      │ → ...        │
│ ...    │ ...          │
└────────┴──────────────┘
```

반면 일반 유저는 여전히
```
-- 일반 유저 조회
SELECT * FROM payment WHERE userId = 100;

실행 과정:
100만 건 → 인덱스 탐색 → 10건만 찾음
→ 매우 효율적!
```

이러한 형태로 데이터가 존재하면 인덱스의 성능이 달라질 수 있으며, **데이터 분포가 균등하지 않기 때문**이다.

## 결론

일반적으로 카디널리티가 높으면(고유값이 많으면) 인덱스가 효율적일 확률이 높아지지만 무조건 보장하는 것은 아니다.

중요한 것은:
1. **카디널리티**: 고유값이 많을수록 좋음
2. **데이터 분포**: 각 값에 대한 레코드 수가 고르게 분포되어야 함
3. **실제 쿼리 패턴**: 자주 조회하는 값의 데이터 양이 적어야 함

결국 인덱스로 탐색한 **결과 셋의 크기가 작도록** 만드는 게 중요하다.