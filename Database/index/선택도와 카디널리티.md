최적의 인덱스를 선택하기 위해 고려해야할 것들 중 하나가 카디널리티와 선택도이다.

# 카디널리티 (Cardinality)와 선택도 (Selectivity)

* **카디널리티**: 특정 칼럼의 고유한 값의 개수
* **선택도**: 전체 레코드 중 고유한 값의 비율 (카디널리티 / 전체 레코드 수)
* 카디널리티가 높을수록(고유값이 많을수록) 인덱스를 이용한 조회 효율이 높아진다.

무슨말인지 예시를 통해 알아보자.
```ddl
create table payment(
    orderId int not null primary key,
    userId int not null,
    createdDate Date not null
)
```

가령 다음과 같은 테이블에서 특정 유저가 구입한 주문을 조회한다고 해보자.
```sql
select * 
from payment
where userId = 123
```

총 payment 레코드가 100만 건이고, userId로 인덱스를 추가한다고 해보자.

## 경우 1: userId 인덱스 (카디널리티 높음)

유저가 10만 명이고 유저당 평균 10건의 구매를 했다고 하면:
- **카디널리티**: 10만 (고유 userId 개수)
- **선택도**: 10만 / 100만 = 0.1 (10%)
- **각 userId당 평균**: 100만 / 10만 = 10건

특정 userId로 조회 시:
```
100만 건 → 인덱스로 10건만 찾음 (매우 효율적)
```

## 경우 2: createdDate 인덱스 (카디널리티 낮음)

10일간의 데이터가 100만 건이라고 해보자:
- **카디널리티**: 10 (고유 날짜 개수)
- **선택도**: 10 / 100만 = 0.00001 (0.001%)
- **각 날짜당 평균**: 100만 / 10 = 10만 건
```sql
select * 
from payment
where createdDate = '2025-11-03'
```

특정 날짜로 조회 시:
```
100만 건 → 인덱스로 10만 건 찾음 (비효율적)
```

이처럼 **카디널리티(고유값의 개수)** 는 효율적인 인덱스 탐색을 위한 중요한 척도가 된다.

## 주의: 카디널리티가 높아도 비효율적일 수 있음

하지만, 무조건 카디널리티가 높다고 해서 효율적인 탐색을 보장하는 것은 아니다.

처음의 userId 예시에서 일반 유저는 10건 미만이지만, 특정 VIP 유저는 1만 건 이상의 구매를 했다고 가정해보자.
```sql
select * 
from payment
where userId = 100  -- VIP 유저 아이디
```

이 경우:
```
100만 건 → 인덱스로 1만 건 찾음 ⚠️
→ 여전히 1만 건을 처리해야 하므로 성능이 느릴 수 있음
```

이는 **데이터 분포가 균등하지 않기 때문**이다.

## 결론

일반적으로 카디널리티가 높으면(고유값이 많으면) 인덱스가 효율적일 확률이 높아지지만 무조건 보장하는 것은 아니다.

중요한 것은:
1. **카디널리티**: 고유값이 많을수록 좋음
2. **데이터 분포**: 각 값에 대한 레코드 수가 고르게 분포되어야 함
3. **실제 쿼리 패턴**: 자주 조회하는 값의 데이터 양이 적어야 함

결국 인덱스로 탐색한 **결과 셋의 크기가 작도록** 만드는 게 중요하다.